package s260344611;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Random;

import boardgame.Board;
import boardgame.Move;
import boardgame.Player;
import halma.*;
import s260344611.utils.BoardUtils;
import s260344611.utils.GenericTreeNode;


public class s260344611Player extends Player {
	
    private ArrayList<CCMove> moveSequence = new ArrayList<CCMove>();
    private boolean inMoveSequence = true;
    private boolean initialized = false;
    
    private static int bestMoveVal = 0;
    Random rand = new Random();
    
    public s260344611Player() { 
    	super("s260344611"); 
    }
    public s260344611Player(String s) { 
    	super(s); 
    }
    
    public Board createBoard() { return new CCBoard(); }

    public Move chooseMove(Board board) {
    	// Perform initialization if it hasn't already been done
    	if (!initialized) {
        	moveSequence = setStartingSequence(playerID);
        	BoardUtils.initPlayerBases();
        	initialized = true;
    	}
    	
// DEBUG
//    	try {
//			Thread.sleep(50);
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
    	
    	bestMoveVal = 0;
    	CCMove selectedMove;      	
        CCBoard b = (CCBoard) board;
       
        // If there is an active move sequence to perform, execute it
		while(inMoveSequence) {
			// Loop until a move is selected or the move queue is empty	    		
    		selectedMove = moveSequence.get(0);
    		moveSequence.remove(0);
    		if (moveSequence.isEmpty()) {
    			// If the move sequence buffer is empty, it means that the sequence is over
    			inMoveSequence = false;
    		}
// DEBUG    System.out.println(selectedMove.toPrettyString());
    		if (b.isLegal(selectedMove)) {
    			// Make sure that the selected move is legal
    			return selectedMove;
    		}
		}
        
        Point goal = BoardUtils.getGoal(board, playerID);        
    	ArrayList<Point> visited = new ArrayList<Point>();
        GenericTreeNode<CCMove> moveTree = new GenericTreeNode<CCMove>(new CCMove(playerID, null, null), null, 0);    
        ArrayList< GenericTreeNode<CCMove> > bestMoves = new ArrayList< GenericTreeNode<CCMove> >();        
        ArrayList<Point> pieces = b.getPieces(playerID);
        
        // Expand the move tree for all of the player's pieces
        for (Point p : pieces) {
        	visited.clear();
        	getBestMovesForPiece(b, moveTree, 
        						visited, bestMoves, 
        						p, goal, playerID);
        }
        
// DEBUG        
//        System.out.println("\n----------\nBest moves (value:" + bestMoveVal + ")\n----------");
//        for (GenericTreeNode<CCMove> p : bestMoves) {
//        	System.out.println(p.getData().toPrettyString());
//        }
//        System.out.println("----------");
        

    	// If every legal move is negative in value, just pick a random one to get "unstuck" 
        if (bestMoves.isEmpty()) {       	
        	ArrayList<CCMove> legalMoves =  b.getLegalMoves();
        	return legalMoves.get(rand.nextInt(legalMoves.size()));
        }
        
        // Return the best move. If there is a tie, break it with a random generator.
        GenericTreeNode<CCMove> selectedNode = bestMoves.get(rand.nextInt(bestMoves.size()));
        
        // Get the move sequence for the best move
        moveSequence = getMoveSequence(selectedNode, playerID);
        
// DEBUG        
//        for (CCMove move : moveSequence) {
//        	System.out.println("-> Selected Move: " + move.toPrettyString());
//        }
//        System.out.println("----------\n");
        
        // Pop the first move in the sequence and return it
        selectedMove = moveSequence.get(0);
        moveSequence.remove(0);
        if (moveSequence.size() > 0) 
        	inMoveSequence = true;
        
        return selectedMove;      
    }
    
    /**
     * Recursively generates a tree of all legal moves for a given piece, including multi-hop chains. Evaluates each move 
     * according to an evaluation function and stores the best moves in a list.
     * 
     * @param board			The game board to work with
     * @param moveTreeNode	Pointer to the tree node corresponding to the previous move (i.e. the parent node)
     * @param visited		List of nodes which have already been visited in this branch (to prevent infinite loops)
     * @param bestMoves		List to store the best moves generated by this function
     * @param p				Coordinate of the piece that we want to verify
     * @param goal			Coordinate of the target
     * @param playerID		The current player
     */
    public static void getBestMovesForPiece(Board board, GenericTreeNode<CCMove> moveTreeNode, 
    									   ArrayList<Point> visited, ArrayList< GenericTreeNode<CCMove> > bestMoves, 
    									   Point p, Point goal, int playerID) {
    	CCBoard b = (CCBoard) board;    	
    	ArrayList<CCMove> moves = b.getLegalMoveForPiece(p, playerID); 
    	visited.add(p);
    	
    	Point dest;
    	int val;
    	
    	for (CCMove move : moves) {

        	int currVal = moveTreeNode.getValue();
    		dest = move.getTo();
    		
    		if (!visited.contains(dest)) {
	    		//explore this move
				CCBoard newBoard = (CCBoard) b.clone();
				newBoard.move(move);
    			
    			if (dest != null) {
    				val = BoardUtils.computeMoveValue(newBoard, move, goal, playerID);
    			}
    			else {
    				val = 0;    
    			}	
	    		
//    			System.out.print("(" + currVal + ")");
	    		currVal += val;
//    			System.out.println(" + " + val + " = " + currVal + ": " + move.toPrettyString());
				GenericTreeNode<CCMove> newMove = new GenericTreeNode<CCMove>(move, moveTreeNode, currVal);
				
	    		if (val < 0) {
	    			//ignore moves with negative value to save time
	    			continue;
	    		}
	    		else if (currVal > bestMoveVal) {
	    			bestMoveVal = currVal;
	    			bestMoves.clear();
	    			bestMoves.add(newMove);
	    		}
	    		else if (currVal == bestMoveVal) {
	    			bestMoves.add(newMove);
	    		}	    		
	    		
				moveTreeNode.addChild(newMove);
				
				//recursion step
				getBestMovesForPiece(newBoard, newMove, 
									visited, bestMoves, 
									dest, goal, playerID);				
    		} 		
    	}
    }    

    /**
     * Gets the hard-coded starting sequence from BoardUtils and returns it
     * 
     * @param playerID		The current player
     * @return
     */
    public static ArrayList<CCMove> setStartingSequence(int playerID) {
    	ArrayList<CCMove> m = new ArrayList<CCMove>();    
    	String[] sequence = BoardUtils.getStartSequence();
    	String moveString;
    	for (String s : sequence) {
    		moveString = playerID + " " + s;
    		m.add(BoardUtils.convertToPlayer( new CCMove(moveString) ));
    	}   	
    	return m;
    }
    
    /**
     * Starts at a node and moves up the tree, adding its parents to the current move sequence (in reverse order)
     * 
     * @param moveTreeNode	The starting node, which corresponds to the last node in the move sequence
     * @param playerID		The current player
     * @return
     */
    public static ArrayList<CCMove> getMoveSequence(GenericTreeNode<CCMove> moveTreeNode, int playerID) {
    	
    	CCMove move;
    	ArrayList<CCMove> moveSeq = new ArrayList<CCMove>();
    	moveSeq.add(moveTreeNode.getData());
    	
    	GenericTreeNode<CCMove> parent = moveTreeNode.getParent();
    	while (parent != null) {
    		moveTreeNode = parent;
    		move = moveTreeNode.getData();
    		if (move.getTo() != null)
    			moveSeq.add(0, move); //insert the parent node
    		else
    			moveSeq.add(move); 	//always put the "end turn" node at the end
    		parent = moveTreeNode.getParent();
    	}
    	return moveSeq;
    }
    
}
